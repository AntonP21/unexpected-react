{"version":3,"sources":["../src/testRendererAssertions.js"],"names":[],"mappings":"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","file":"testRendererAssertions.js","sourcesContent":["import UnexpectedHtmlLike from 'unexpected-htmllike';\nimport ReactTestRendererAdapter from 'unexpected-htmllike-testrenderer-adapter';\nimport React from 'react';\n\n\n// This is a dummy constant object used as a unique identifier for a pending\n// event. This should be a Symbol in ES6, but would mean requiring polyfills\n// for browsers that don't support it\n// See issue #18\nconst PENDING_TEST_EVENT_TYPE = { PENDING_TEST_EVENT: 'Pending test event' };\n\nfunction getDefaultOptions(flags) {\n    return {\n        diffWrappers: flags.exactly || flags.withAllWrappers,\n        diffExtraChildren: flags.exactly || flags.withAllChildren,\n        diffExtraAttributes: flags.exactly,\n        diffExactClasses: flags.exactly,\n        diffExtraClasses: flags.exactly\n    };\n}\n\nfunction installInto(expect) {\n\n    expect.addType({\n\n        name: 'ReactPendingTestEvent',\n\n        base: 'object',\n\n        identify: function (value) {\n            return value && typeof value === 'object' && value.$$typeof === PENDING_TEST_EVENT_TYPE;\n        }\n\n    });\n\n\n    expect.addAssertion(['<ReactTestRenderer> to have [exactly] rendered <ReactElement>',\n        '<ReactTestRenderer> to have rendered [with all children] [with all wrappers] <ReactElement>'], function (expect, subject, renderOutput) {\n        var actual = subject.toJSON();\n        return expect(actual, 'to have [exactly] rendered [with all children] [with all wrappers]', renderOutput);\n    });\n\n\n    expect.addAssertion(['<ReactTestRendererOutput> to have [exactly] rendered <ReactElement>',\n        '<ReactTestRendererOutput> to have rendered [with all children] [with all wrappers] <ReactElement>'], function (expect, subject, expected) {\n\n        const exactly = this.flags.exactly;\n        const withAllChildren = this.flags['with all children'];\n        const withAllWrappers = this.flags['with all wrappers'];\n\n        const testAdapter = new ReactTestRendererAdapter();\n        const jsxAdapter = new ReactElementAdapter();\n        const testHtmlLike = new UnexpectedHtmlLike(testAdapter);\n        if (!exactly) {\n            testAdapter.setOptions({ concatTextContent: true });\n            jsxAdapter.setOptions({ concatTextContent: true });\n        }\n\n        const options = getDefaultOptions({ exactly, withAllWrappers, withAllChildren });\n\n        const diffResult = testHtmlLike.diff(jsxAdapter, subject, expected, expect, options);\n\n        return testHtmlLike.withResult(diffResult, result => {\n\n            if (result.weight !== 0) {\n                return expect.fail({\n                    diff: function (output, diff, inspect) {\n                        return {\n                            diff: output.append(testHtmlLike.render(result, output.clone(), diff, inspect))\n                        };\n                    }\n                });\n            }\n        });\n\n    });\n\n    /*\n    expect.addAssertion(['<ReactTestRenderer> [not] to contain [exactly] <ReactElement|string>',\n        '<ReactShallowRenderer> [not] to contain [with all children] [with all wrappers] <ReactElement|string>'], function (expect, subject, renderOutput) {\n        var actual = subject.toJSON();\n        return expect(actual, '[not] to contain [exactly] [with all children] [with all wrappers]', renderOutput);\n    });\n\n    expect.addAssertion(['<ReactTestRendererOutput> [not] to contain [exactly] <ReactElement|string>',\n        '<ReactTestRendererOutput> [not] to contain [with all children] [with all wrappers] <ReactElement|string>'], function (expect, subject, expected) {\n\n        var not = this.flags.not;\n        var exactly = this.flags.exactly;\n        var withAllChildren = this.flags['with all children'];\n        var withAllWrappers = this.flags['with all wrappers'];\n\n        var testAdapter = new ReactTestRendererAdapter();\n        var jsxAdapter = new ReactElementAdapter();\n        var testHtmlLike = new UnexpectedHtmlLike(testAdapter);\n        if (!exactly) {\n            testAdapter.setOptions({ concatTextContent: true });\n            jsxAdapter.setOptions({ concatTextContent: true });\n        }\n\n        var options = getDefaultOptions({ exactly, withAllWrappers, withAllChildren });\n\n        const containsResult = testHtmlLike.contains(testAdapter, subject, expected, expect, options);\n\n        return testHtmlLike.withResult(containsResult, result => {\n\n            if (not) {\n                if (result.found) {\n                    expect.fail({\n                        diff: (output, diff, inspect) => {\n                            return {\n                                diff: output.error('but found the following match').nl().append(testHtmlLike.render(result.bestMatch, output.clone(), diff, inspect))\n                            };\n                        }\n                    });\n                }\n                return;\n            }\n\n            if (!result.found) {\n                expect.fail({\n                    diff: function (output, diff, inspect) {\n                        return {\n                            diff: output.error('the best match was').nl().append(testHtmlLike.render(result.bestMatch, output.clone(), diff, inspect))\n                        };\n                    }\n                });\n            }\n        });\n    });\n\n    expect.addAssertion(['<ReactElement> queried for [exactly] <ReactElement> <assertion?>',\n        '<ReactElement> queried for [with all children] [with all wrapppers] <ReactElement> <assertion?>'], function (expect, subject, query) {\n\n        var exactly = this.flags.exactly;\n        var withAllChildren = this.flags['with all children'];\n        var withAllWrappers = this.flags['with all wrappers'];\n\n        var adapter = new ReactElementAdapter();\n        var jsxHtmlLike = new UnexpectedHtmlLike(adapter);\n        if (!exactly) {\n            adapter.setOptions({ concatTextContent: true });\n        }\n\n        const options = getDefaultOptions({ exactly, withAllWrappers, withAllChildren });\n        options.findTargetAttrib = 'queryTarget';\n\n        const containsResult = jsxHtmlLike.contains(adapter, subject, query, expect, options);\n\n        return jsxHtmlLike.withResult(containsResult, function (result) {\n\n            if (!result.found) {\n                expect.fail({\n                    diff: (output, diff, inspect) => {\n                        const resultOutput = {\n                            diff: output.error('`queried for` found no match.')\n                        };\n                        if (result.bestMatch) {\n                            resultOutput.diff.error('  The best match was')\n                                .nl()\n                                .append(jsxHtmlLike.render(result.bestMatch, output.clone(), diff, inspect));\n                        }\n                        return resultOutput;\n                    }\n                });\n            }\n\n            return expect.shift(result.bestMatch.target || result.bestMatchItem);\n        });\n    });\n\n    expect.addAssertion(['<ReactShallowRenderer> queried for [exactly] <ReactElement> <assertion?>',\n        '<ReactShallowRenderer> queried for [with all children] [with all wrapppers] <ReactElement> <assertion?>'\n    ], function (expect, subject, query, assertion) {\n        return expect.apply(expect,\n            [\n                subject.getRenderOutput(), 'queried for [exactly] [with all children] [with all wrappers]', query\n            ].concat(Array.prototype.slice.call(arguments, 3)));\n    });\n\n\n    expect.addAssertion('<ReactShallowRenderer> with event <string> <assertion?>', function (expect, subject, eventName) {\n        if (arguments.length > 3) {\n            return expect.shift({\n                $$typeof: PENDING_SHALLOW_EVENT_TYPE,\n                renderer: subject,\n                eventName: eventName\n            });\n        } else {\n            triggerEvent(subject, null, eventName);\n            return expect.shift(subject);\n        }\n    });\n\n    expect.addAssertion('<ReactShallowRenderer> with event <string> <object> <assertion?>', function (expect, subject, eventName, args) {\n        if (arguments.length > 4) {\n            return expect.shift({\n                $$typeof: PENDING_SHALLOW_EVENT_TYPE,\n                renderer: subject,\n                eventName: eventName,\n                eventArgs: args\n            });\n        } else {\n            triggerEvent(subject, null, eventName, args);\n            return expect.shift(subject);\n        }\n    });\n\n    expect.addAssertion('<ReactElement> with event <string> <assertion?>', function (expect, subject, eventName) {\n\n        const renderer = TestUtils.createRenderer();\n        renderer.render(subject);\n        return expect.apply(expect, [renderer, 'with event'].concat(Array.prototype.slice.call(arguments, 2)))\n\n    });\n\n    expect.addAssertion('<ReactElement> with event <string> <object> <assertion?>', function (expect, subject, eventName, eventArgs) {\n\n        const renderer = TestUtils.createRenderer();\n        renderer.render(subject);\n        return expect.apply(expect, [renderer, 'with event'].concat(Array.prototype.slice.call(arguments, 2)))\n    });\n\n\n    expect.addAssertion('<ReactPendingShallowEvent> on [exactly] [with all children] [with all wrappers] <ReactElement> <assertion?>', function (expect, subject, target) {\n        const adapter = new ReactElementAdapter({ convertToString: true, concatTextContent: true });\n        const jsxHtmlLike = new UnexpectedHtmlLike(adapter);\n\n        const exactly = this.flags.exactly;\n        const withAllChildren = this.flags['with all children'];\n        const withAllWrappers = this.flags['with all wrappers'];\n\n        const options = getDefaultOptions({ exactly, withAllWrappers, withAllChildren });\n        options.findTargetAttrib = 'eventTarget';\n\n        const containsResult = jsxHtmlLike.contains(adapter, subject.renderer.getRenderOutput(), target, expect, options);\n        return jsxHtmlLike.withResult(containsResult, result => {\n            if (!result.found) {\n                return expect.fail({\n                    diff: function (output, diff, inspect) {\n                        output.error('Could not find the target for the event. ');\n                        if (result.bestMatch) {\n                            output.error('The best match was').nl().nl().append(jsxHtmlLike.render(result.bestMatch, output.clone(), diff, inspect))\n                        }\n                        return output;\n                    }\n                })\n            }\n\n            const newSubject = Object.assign({}, subject, {\n                target: result.bestMatch.target || result.bestMatchItem\n            });\n\n            if (arguments.length > 3) {\n                return expect.shift(newSubject);\n            } else {\n                triggerEvent(newSubject.renderer, newSubject.target, newSubject.eventName, newSubject.eventArgs);\n                return expect.shift(newSubject.renderer);\n            }\n        });\n    });\n\n\n    function triggerEvent(renderer, target, eventName, eventArgs) {\n\n        if (!target) {\n            target = renderer.getRenderOutput();\n        }\n\n        const handlerPropName = 'on' + eventName[0].toUpperCase() + eventName.substr(1);\n        const handler = target.props[handlerPropName];\n        if (typeof handler !== 'function') {\n            return expect.fail({\n                diff: function (output) {\n                    return output.error('No handler function prop ').text(\"'\" + handlerPropName + \"'\").error(' on the target element');\n\n                }\n            })\n        }\n        handler(eventArgs);\n        return renderer;\n    }\n\n\n    expect.addAssertion('<ReactPendingShallowEvent> to have [exactly] rendered [with all children] [with all wrappers] <ReactElement>', function (expect, subject, expected) {\n\n        triggerEvent(subject.renderer, subject.target, subject.eventName, subject.eventArgs);\n        return expect(subject.renderer, 'to have [exactly] rendered [with all children] [with all wrappers]', expected);\n    });\n\n    expect.addAssertion('<ReactPendingShallowEvent> [and] with event <string> <assertion?>', function (expect, subject, eventName) {\n\n        triggerEvent(subject.renderer, subject.target, subject.eventName, subject.eventArgs);\n        if (arguments.length > 3) {\n            return expect.shift({\n                $$typeof: PENDING_SHALLOW_EVENT_TYPE,\n                renderer: subject.renderer,\n                eventName: eventName\n            });\n        } else {\n            triggerEvent(subject.renderer, null, eventName);\n            return expect.shift(subject.renderer);\n        }\n    });\n\n    expect.addAssertion('<ReactPendingShallowEvent> [and] with event <string> <object> <assertion?>', function (expect, subject, eventName, eventArgs) {\n\n        triggerEvent(subject.renderer, subject.target, subject.eventName, subject.eventArgs);\n        if (arguments.length > 4) {\n            return expect.shift({\n                $$typeof: PENDING_SHALLOW_EVENT_TYPE,\n                renderer: subject.renderer,\n                eventName: eventName,\n                eventArgs: eventArgs\n            });\n        } else {\n            triggerEvent(subject.renderer, null, eventName, eventArgs);\n            return expect.shift(subject.renderer);\n        }\n    });\n\n    expect.addAssertion(['<ReactPendingShallowEvent> [not] to contain [exactly] <ReactElement>',\n        '<ReactPendingShallowEvent> [not] to contain [with all children] [with all wrappers] <ReactElement>'], function (expect, subject, expected) {\n\n        triggerEvent(subject.renderer, subject.target, subject.eventName, subject.eventArgs);\n        return expect(subject.renderer, '[not] to contain [exactly] [with all children] [with all wrappers]', expected);\n    });\n\n\n    expect.addAssertion(['<ReactPendingShallowEvent> queried for [exactly] <ReactElement> <assertion?>',\n        '<ReactPendingShallowEvent> queried for [with all children] [with all wrappers] <ReactElement> <assertion?>'], function (expect, subject, expected) {\n\n        triggerEvent(subject.renderer, subject.target, subject.eventName, subject.eventArgs);\n        return expect.apply(expect,\n            [subject.renderer, 'queried for [exactly] [with all children] [with all wrappers]', expected]\n                .concat(Array.prototype.slice.call(arguments, 3)));\n    });\n\n\n    expect.addAssertion('<ReactElement> to equal <ReactElement>', function (expect, subject, value) {\n        return expect(subject, 'to have exactly rendered', value);\n    });\n\n\n    expect.addAssertion('<ReactShallowRenderer> to equal <ReactElement>', function (expect, subject, value) {\n        return expect(subject.getRenderOutput(), 'to have exactly rendered', value);\n    });\n\n\n    expect.addAssertion('<ReactElement> to satisfy <ReactElement>', function (expect, subject, renderOutput) {\n        return expect(subject, 'to have rendered', renderOutput);\n    });\n    */\n\n}\n\nexport { installInto };\n"]}